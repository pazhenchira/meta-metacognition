# Deployment Guide: Using Meta-Orchestrator with Your Apps

**Date**: November 24, 2025  
**Version**: 1.1.0

---

## Overview

This guide explains how to use the meta-orchestrator with your applications. There are two main scenarios:

1. **Building a NEW application** from scratch
2. **Upgrading an EXISTING application** built with an older meta-orchestrator

---

## Recommended Directory Structure

### Option 1: Separate Meta-Orchestrator Repository (Recommended)

Keep meta-orchestrator in its own directory and copy it into your app projects:

```
your-projects/
├── meta-metacognition/          # This repository (engine)
│   ├── AGENTS.md
│   ├── principles.md
│   ├── meta_config.json
│   ├── VERSION
│   └── ... (all engine files)
│
├── my-stock-analyzer/           # Your app
│   ├── .meta/                   # Copy meta-orchestrator here
│   │   ├── AGENTS.md
│   │   ├── principles.md
│   │   ├── meta_config.json
│   │   └── ... (all engine files)
│   ├── app_intent.md            # Your app's requirements
│   ├── .meta-version            # Generated by meta-orchestrator
│   ├── .meta-manifest.json      # Generated by meta-orchestrator
│   ├── src/                     # Generated app code
│   └── tests/                   # Generated tests
│
└── my-crypto-tracker/           # Another app
    ├── .meta/                   # Copy meta-orchestrator here too
    └── ...
```

**Benefits**:
- ✅ Clear separation between engine and app
- ✅ Easy to update engine (just copy new `.meta/` files)
- ✅ Each app can use different meta-orchestrator versions
- ✅ `.meta/` in `.gitignore` (optional) or committed for reproducibility

### Option 2: Root-Level Files (Simpler)

Copy meta-orchestrator files directly into your app root:

```
my-stock-analyzer/
├── AGENTS.md                    # Meta-orchestrator engine
├── principles.md
├── meta_config.json
├── VERSION
├── ... (all engine files)
├── app_intent.md                # Your app's requirements
├── .meta-version                # Generated
├── .meta-manifest.json          # Generated
├── src/                         # Generated app code
└── tests/                       # Generated tests
```

**When to use**: Simpler for single-app projects, but harder to upgrade engine later.

---

## For NEW Applications

### Step 1: Create Your App Directory

```powershell
# Create new app directory
mkdir my-stock-analyzer
cd my-stock-analyzer
```

### Step 2: Copy Meta-Orchestrator Files

**Option A: Using `.meta/` directory (recommended)**

```powershell
# Copy all meta-orchestrator files into .meta/
mkdir .meta
Copy-Item -Path C:\Dev\meta-metacognition\* -Destination .\.meta\ -Recurse -Exclude .git,README.md,DEPLOYMENT_GUIDE.md
```

**Option B: Root-level files**

```powershell
# Copy meta-orchestrator files to app root
Copy-Item -Path C:\Dev\meta-metacognition\* -Destination .\ -Recurse -Exclude .git,README.md,DEPLOYMENT_GUIDE.md
```

### Step 3: Create `app_intent.md`

```powershell
# Create your app's intent file
New-Item -Path app_intent.md -ItemType File
```

Edit `app_intent.md` with your application requirements:

```markdown
# Application Intent: Stock Analyzer

## Purpose
Build a CLI tool that analyzes stock market data and generates investment reports.

## Key Features
- Fetch real-time stock prices from Yahoo Finance API
- Calculate technical indicators (RSI, MACD, moving averages)
- Generate daily/weekly reports in PDF format
- Store historical data in PostgreSQL

## Constraints
- Must run on Windows/Linux/macOS
- Free-tier APIs only (no paid subscriptions)
- Performance: Handle 100+ stocks efficiently
- Privacy: All data stored locally, no cloud dependencies
```

### Step 4: Run Meta-Orchestrator

```powershell
# If using .meta/ directory
codex exec "Act as the meta-orchestrator described in .meta/AGENTS.md and execute the full pipeline."

# If using root-level files
codex exec "Act as the meta-orchestrator described in AGENTS.md and execute the full pipeline."
```

**What happens**:
1. Meta-orchestrator reads `app_intent.md`
2. Asks clarifying questions about requirements
3. Generates LEGO architecture (`lego_plan.json`)
4. Builds all components in parallel isolated sessions
5. Generates tests (unit, integration, system)
6. Creates documentation
7. Writes `.meta-version` and `.meta-manifest.json`

### Step 5: Your App is Ready!

```
my-stock-analyzer/
├── .meta/                       # Meta-orchestrator engine
├── app_intent.md                # Your requirements
├── .meta-version                # v1.1.0
├── .meta-manifest.json          # Generated files tracking
├── requirements.md              # Detailed requirements
├── lego_plan.json               # Architecture
├── src/
│   ├── config_validator.py      # Always generated first
│   ├── stock_fetcher.py
│   ├── technical_analyzer.py
│   └── report_generator.py
├── tests/
│   ├── test_stock_fetcher.py
│   ├── integration/
│   └── system/
├── dependencies.md
├── external_services.md
├── .env.example
└── README.md
```

---

## For EXISTING Applications

### Scenario 1: App Built with Old Meta-Orchestrator

Your app was built with meta-orchestrator v0.9 or v1.0, now you want to upgrade.

### Step 1: Backup Your App

```powershell
# Create backup
Copy-Item -Path my-existing-app -Destination my-existing-app-backup -Recurse
cd my-existing-app
```

### Step 2: Create Version Tracking Files

```powershell
# Mark current version (0.9.0 = pre-Phase-1)
@"
{
  "meta_orchestrator_version": "0.9.0",
  "created_date": "2025-11-01",
  "features": ["lego_architecture", "unit_tests"]
}
"@ | Out-File -FilePath .meta-version -Encoding utf8

# Protect your custom files
@"
{
  "generated_by": "meta-orchestrator/0.9.0",
  "files": {
    "src/my_custom_feature.py": {
      "user_modified": true,
      "regenerate_on_upgrade": false
    },
    "src/another_custom_file.py": {
      "user_modified": true,
      "regenerate_on_upgrade": false
    }
  }
}
"@ | Out-File -FilePath .meta-manifest.json -Encoding utf8
```

### Step 3: Copy New Meta-Orchestrator Files

**If your app has no `.meta/` directory yet:**

```powershell
# Create .meta/ and copy new engine files
mkdir .meta
Copy-Item -Path C:\Dev\meta-metacognition\* -Destination .\.meta\ -Recurse -Exclude .git,README.md,DEPLOYMENT_GUIDE.md
```

**If your app has root-level meta-orchestrator files:**

```powershell
# Update root-level files
Copy-Item -Path C:\Dev\meta-metacognition\AGENTS.md,principles.md,meta_config.json,VERSION,SESSION_ISOLATION.md,TESTING_STRATEGY.md,CONFIG_VALIDATION.md,agent_runtime.json -Destination .\ -Force
Copy-Item -Path C:\Dev\meta-metacognition\runtime_adapters -Destination .\ -Recurse -Force
```

### Step 4: Run Upgrade

```powershell
# Test on a branch first
git checkout -b upgrade-meta-orchestrator

# Run upgrade (meta-orchestrator detects UPGRADE MODE)
codex exec "Act as meta-orchestrator from AGENTS.md. Read .meta-version (0.9.0) and VERSION (1.1.0). This is UPGRADE MODE. Read .meta-manifest.json for protected files. Generate upgrade plan showing new features (config_validation, session_isolation, integration_tests). Show plan and wait for approval."
```

**What happens**:
1. Meta reads `.meta-version` → 0.9.0
2. Meta reads `VERSION` → 1.1.0
3. Meta detects: **ENGINE UPGRADE MODE**
4. Meta shows upgrade plan:
   ```
   Upgrade Plan: 0.9.0 → 1.1.0
   
   New Features:
   - Config validation LEGO
   - Integration tests
   - System tests
   - Session isolation (internal)
   
   Will Add:
   - src/config_validator.py
   - tests/integration/
   - tests/system/
   
   Protected (Won't Touch):
   - src/my_custom_feature.py (user_modified: true)
   
   Approve? (y/n):
   ```
5. You review and approve
6. Meta applies upgrade safely
7. Meta updates `.meta-version` → 1.1.0

### Step 5: Test and Merge

```powershell
# Review changes
git diff

# Test everything
pytest

# If good, merge
git checkout main
git merge upgrade-meta-orchestrator
```

---

## Scenario 2: App NOT Built with Meta-Orchestrator

You have an existing app built manually. You want meta-orchestrator to manage it.

### Option A: Let Meta-Orchestrator Rebuild (Cleanest)

```powershell
# 1. Document your current app in app_intent.md
cd my-manual-app
New-Item -Path app_intent.md -ItemType File
# Edit app_intent.md to describe your app

# 2. Backup custom code
mkdir ../my-manual-app-backup
Copy-Item -Path .\src\* -Destination ..\my-manual-app-backup\ -Recurse

# 3. Copy meta-orchestrator
mkdir .meta
Copy-Item -Path C:\Dev\meta-metacognition\* -Destination .\.meta\ -Recurse -Exclude .git,README.md,DEPLOYMENT_GUIDE.md

# 4. Run meta-orchestrator (NEW APP MODE)
codex exec "Act as meta-orchestrator from .meta/AGENTS.md. Build app from app_intent.md."

# 5. Manually port your custom logic from backup
# Compare generated code with your backup
# Copy over unique business logic
```

### Option B: Gradual Adoption (Safer)

```powershell
# 1. Create parallel structure
cd my-manual-app
mkdir .meta
Copy-Item -Path C:\Dev\meta-metacognition\* -Destination .\.meta\ -Recurse -Exclude .git,README.md,DEPLOYMENT_GUIDE.md

# 2. Create app_intent.md describing ONLY new features you want to add
# Don't describe existing features yet

# 3. Run meta-orchestrator for new features only
codex exec "Act as meta-orchestrator. Build only the new features described in app_intent.md. Place them in src/new/."

# 4. Gradually migrate existing code to LEGO architecture
# One component at a time
```

---

## Directory Cleanup

### What Files to Keep in Your App

**Engine Files** (in `.meta/` if using that structure):
- `AGENTS.md` - Meta-orchestrator behavior
- `principles.md` - Design principles
- `meta_config.json` - Configuration
- `intent.md` - Meta-orchestrator intent
- `VERSION` - Engine version
- `SESSION_ISOLATION.md` - Architecture docs
- `TESTING_STRATEGY.md` - Testing docs
- `CONFIG_VALIDATION.md` - Config validation docs
- `agent_runtime.json` - Runtime adapter config
- `runtime_adapters/` - Runtime adapter scripts
- `session_*.template.json` - Session templates
- `.meta-version.template` - Version template
- `.meta-manifest.template.json` - Manifest template

**App-Specific Files** (in app root):
- `app_intent.md` - YOUR app requirements (you write this)
- `.meta-version` - Generated by meta-orchestrator
- `.meta-manifest.json` - Generated by meta-orchestrator
- `requirements.md` - Generated by meta-orchestrator
- `lego_plan.json` - Generated by meta-orchestrator
- `src/` - Your app code (generated)
- `tests/` - Your tests (generated)

**Documentation Files** (optional to copy):
- `README.md` - Only if you want meta-orchestrator's README
- `UPGRADING.md` - Useful reference
- `QUICKSTART_UPGRADE.md` - Useful reference
- `MODES_QUICK_REFERENCE.md` - Useful reference

**Files to EXCLUDE** (not needed in your app):
- `.git/` - Meta-orchestrator's git history
- `DEPLOYMENT_GUIDE.md` - This file (reference only)
- `PHASE1_SUMMARY.md` - Historical documentation
- `VERSION_MANAGEMENT_SUMMARY.md` - Reference documentation

### Clean Up Old Meta-Orchestrator Files

If you previously copied meta-orchestrator files to root and now want `.meta/` structure:

```powershell
# Move to .meta/ directory
mkdir .meta
Move-Item -Path AGENTS.md,principles.md,meta_config.json,intent.md,VERSION,SESSION_ISOLATION.md,TESTING_STRATEGY.md,CONFIG_VALIDATION.md,agent_runtime.json,runtime_adapters,session_*.template.json,.meta-*.template* -Destination .\.meta\

# Keep these in root (they're app-specific):
# - app_intent.md
# - .meta-version
# - .meta-manifest.json
# - requirements.md
# - lego_plan.json
# - src/, tests/, etc.
```

---

## .gitignore Recommendations

Add to your app's `.gitignore`:

```gitignore
# Meta-orchestrator generated state (ephemeral)
orchestrator_state.json
session_registry.json
lego_state_*.json
env_diagnostics.md
meta_error.md

# Python
__pycache__/
*.py[cod]
.venv/
.pytest_cache/

# Environment
.env
!.env.example

# Keep these (important for versioning):
# .meta-version
# .meta-manifest.json
```

**Optional**: You can add `.meta/` to `.gitignore` if you want to fetch it fresh each time, but I recommend committing it for reproducibility.

---

## Quick Commands Reference

### Copy Meta-Orchestrator to New App

```powershell
# Create app
mkdir my-new-app
cd my-new-app

# Copy engine to .meta/
mkdir .meta
Copy-Item -Path C:\Dev\meta-metacognition\* -Destination .\.meta\ -Recurse -Exclude .git,README.md,DEPLOYMENT_GUIDE.md

# Create app intent
New-Item -Path app_intent.md -ItemType File

# Run meta-orchestrator
codex exec "Act as meta-orchestrator from .meta/AGENTS.md. Build app from app_intent.md."
```

### Upgrade Existing App

```powershell
# Backup
Copy-Item -Path my-app -Destination my-app-backup -Recurse
cd my-app

# Create version files
echo '{"meta_orchestrator_version":"0.9.0"}' | Out-File .meta-version -Encoding utf8
echo '{"files":{"src/custom.py":{"user_modified":true}}}' | Out-File .meta-manifest.json -Encoding utf8

# Update engine
Copy-Item -Path C:\Dev\meta-metacognition\* -Destination .\.meta\ -Recurse -Exclude .git,README.md,DEPLOYMENT_GUIDE.md -Force

# Run upgrade
codex exec "Act as meta-orchestrator. Upgrade this app. Show plan first."
```

### Update Meta-Orchestrator Engine in All Apps

```powershell
# Update meta-orchestrator in multiple apps
$apps = @("my-app1", "my-app2", "my-app3")
foreach ($app in $apps) {
    Copy-Item -Path C:\Dev\meta-metacognition\* -Destination .\$app\.meta\ -Recurse -Exclude .git,README.md,DEPLOYMENT_GUIDE.md -Force
    Write-Host "Updated $app"
}
```

---

## FAQ

**Q: Do I need to copy all meta-orchestrator files into every app?**

A: Yes, for reproducibility. Each app should have its own copy (in `.meta/` directory). This ensures:
- Each app can use different meta-orchestrator versions
- Apps are self-contained and reproducible
- Upgrading meta-orchestrator in one app doesn't affect others

**Q: What if I update meta-orchestrator itself (pull new commits)?**

A: Copy the updated files to your apps' `.meta/` directories, then run upgrade mode:
```powershell
Copy-Item -Path C:\Dev\meta-metacognition\* -Destination .\my-app\.meta\ -Recurse -Force
cd my-app
codex exec "Act as meta-orchestrator. Upgrade this app."
```

**Q: Can I modify meta-orchestrator files in my app?**

A: You CAN, but it's not recommended. Better to:
- Modify `meta_config.json` to tune behavior
- Modify `app_intent.md` to change app requirements
- Keep engine files (AGENTS.md, principles.md) as-is for upgradability

**Q: Where should I commit `.meta/` directory?**

A: **Recommended**: Commit `.meta/` to git for reproducibility. This ensures:
- Anyone cloning your app gets the exact meta-orchestrator version
- You can see engine changes in diffs
- Rollback is easy (git revert)

**Alternative**: Add `.meta/` to `.gitignore` and document required meta-orchestrator version in README.

**Q: How do I clean up old backup files?**

A: Meta-orchestrator no longer creates `.backup` files. The backup files in the meta-orchestrator repo have been removed.

---

## Best Practices

✅ **Use `.meta/` directory structure** for clear separation  
✅ **Commit `.meta-version` and `.meta-manifest.json`** for version tracking  
✅ **Test upgrades on branches** before merging to main  
✅ **Mark custom files in `.meta-manifest.json`** to protect from regeneration  
✅ **Keep meta-orchestrator repo updated** (git pull regularly)  
✅ **Document app requirements in `app_intent.md`**, not in engine files  
✅ **Use version control** (git) for all app development  

---

## Summary

**For NEW apps**:
1. Copy meta-orchestrator files to `.meta/` directory
2. Create `app_intent.md` with requirements
3. Run meta-orchestrator
4. Get production-ready app with tests and docs

**For EXISTING apps**:
1. Create `.meta-version` and `.meta-manifest.json`
2. Copy new meta-orchestrator files
3. Run upgrade mode
4. Get new features without breaking custom code

**Directory structure**: Use `.meta/` for engine, keep app files in root.

**Cleanup**: Old backup files removed, only essential files remain.
